sessions_folder <- "/tmp/omplweb_sessions"

#' get_benchmark_data
#'
#' @description load data from database.
#' There are three possibilities:
#' 1. The user is using the default database.
#' 2. The user has upload their own database.
#' 3. The user has submitted a benchmark job via the OMPL.app web app and
#'    the user wants to look at the database generated by this job.
#'
#' @return a list of tibbles upon success.
#'
#' @noRd
get_benchmark_data <-
  function(session, database, default_database = NULL) {
    #stopifnot(shiny::is.reactive(url_search))
    stopifnot(shiny::is.reactive(database))

    shiny::reactive({
      query <- shiny::parseQueryString(session$clientData$url_search)

      if (is.null(query$user) || is.null(query$job)) {
        if (is.null(database()) || is.null(database()$datapath)) {
          # case 1
          database_file <- default_database
        } else {
          # case 2
          database_file <- database()$datapath
        }
      } else {
        # case 3
        database_file <-
          stringr::str_glue("{sessions_folder}/{query$user}/{query$job}")
      }
      if (!is.null(database_file) && file.exists(database_file)) {
        con <- pool::dbPool(RSQLite::SQLite(), dbname = database_file)
        # benchmark job may not yet be finished so check that "experiments"
        # table exists.
        if ("experiments" %in% DBI::dbListTables(con)) {
          shiny::updateTabsetPanel(session, "navbar", selected = "performance")
          load_database(con)
        } else {
          shinyjs::js$refresh()
        }
      }
    })
  }

#' load_database
#' @description Load a Planner Arena benchmark database into a list of tibbles
#' @param con a DBI connection to the database
#' @export
load_database <- function(con)
{
  # create variables for tables in database
  experiments <- con |>
    dplyr::tbl("experiments") |>
    dplyr::rename(experiment.id = .data$id, experiment = .data$name) |>
    dplyr::collect()

  planner_configs <- con |>
    dplyr::tbl("plannerConfigs") |>
    dplyr::rename(planner.id = .data$id, planner = .data$name) |>
    dplyr::collect() |>
    # this has to come after collect(), since it cannot be translated to SQL
    dplyr::mutate(planner = factor(
      stringr::str_replace_all(.data$planner, "control_|geometric_", "")
    ))
  enums <- con |>
    dplyr::tbl("enums") |>
    dplyr::collect()
  runs <- con |>
    dplyr::tbl("runs") |>
    dplyr::rename(run.id = .data$id) |>
    dplyr::collect() |>
    dplyr::inner_join(
      dplyr::select(planner_configs, planner.id, planner),
      c("plannerid" = "planner.id")
    ) |>
    dplyr::inner_join(
      dplyr::select(experiments, !totaltime:runcount &
                      !hostname:setup),
      c("experimentid" = "experiment.id")
    )

  for (enum in unique(enums$name)) {
    enum_values <-
      enums |> dplyr::filter(.data$name == enum) |> dplyr::pull(.data$value, .data$description)
    runs[[enum]] <-
      factor(runs[[enum]], levels = enum_values, labels = names(enum_values))
  }
  progress <- con |>
    dplyr::tbl("progress") |>
    dplyr::collect()
  problem_names <-
    experiments |> dplyr::pull(.data$experiment) |> unique()

  list(
    experiments = experiments,
    planner_configs = planner_configs,
    runs = runs,
    progress = progress,
    problem_names = problem_names
  )
}
